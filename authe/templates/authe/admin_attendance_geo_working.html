{% extends 'main/base.html' %}

{% block title %}Attendance Map - SAT-SHINE{% endblock %}

{% block content %}
<div style="padding: 20px;">
    <h2>Attendance Location Map</h2>
    
    <!-- Filter Controls -->
    <div style="display: flex; gap: 15px; margin-bottom: 20px; align-items: center; background: #f8f9fa; padding: 15px; border-radius: 8px;">
        <div>
            <label for="dateFilter" style="font-weight: 600; margin-right: 5px;">Date:</label>
            <input type="date" id="dateFilter" value="{{ selected_date|date:'Y-m-d' }}" style="padding: 5px; border: 1px solid #ccc; border-radius: 4px;">
        </div>
        <div>
            <label for="statusFilter" style="font-weight: 600; margin-right: 5px;">Status:</label>
            <select id="statusFilter" style="padding: 5px; border: 1px solid #ccc; border-radius: 4px;">
                <option value="">All Status</option>
                <option value="present">Present</option>
                <option value="absent">Absent</option>
                <option value="half_day">Half Day</option>
            </select>
        </div>
        <button onclick="applyFilters()" style="padding: 6px 12px; background: #1e3a8a; color: white; border: none; border-radius: 4px; cursor: pointer;">Apply Filters</button>
    </div>
    
    <div id="map" style="height: 500px; width: 100%; border: 1px solid #ccc;"></div>
    
    <div id="legend" style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 5px;">
        <h5>Legend</h5>
        <div style="display: flex; gap: 20px; flex-wrap: wrap;">
            <div><span style="color: green;">●</span> Present (On Time)</div>
            <div><span style="color: orange;">●</span> Present (Late)</div>
            <div><span style="color: red;">●</span> Absent</div>
            <div><span style="color: blue;">●</span> Half Day</div>
        </div>
        <div style="margin-top: 10px;">
            <h6>GPS Accuracy Indicators (Border Colors):</h6>
            <div style="display: flex; gap: 20px; flex-wrap: wrap; font-size: 13px;">
                <div><span style="color: green; font-weight: bold;">Green Border:</span> High Accuracy (≤20m)</div>
                <div><span style="color: orange; font-weight: bold;">Orange Border:</span> Moderate Accuracy (21-50m)</div>
                <div><span style="color: red; font-weight: bold;">Red Border:</span> Low Accuracy (>50m)</div>
            </div>
        </div>
        <div style="margin-top: 10px;">
            <h6>Multiple Users at Same Location:</h6>
            <div style="font-size: 13px;">
                <div>• When multiple employees work at the same GPS location, markers are automatically spread in a small circle</div>
                <div>• Click on any marker to see individual details, or click between markers to see all employees at that location</div>
                <div>• Clustered markers show abbreviated Employee IDs (last 3 characters) for better visibility</div>
            </div>
        </div>
    </div>
</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v7.2.2/ol.css" type="text/css">
<script src="https://cdn.jsdelivr.net/npm/ol@v7.2.2/dist/ol.js"></script>

<script>
// Initialize map with higher zoom for accuracy
const map = new ol.Map({
    target: 'map',
    layers: [
        new ol.layer.Tile({
            source: new ol.source.OSM()
        })
    ],
    view: new ol.View({
        center: ol.proj.fromLonLat([72.5714, 23.0225]), // Ahmedabad center
        zoom: 12, // Higher zoom for better accuracy
        maxZoom: 20 // Allow very high zoom for precision
    })
});

// Create vector source for markers
const vectorSource = new ol.source.Vector();
const vectorLayer = new ol.layer.Vector({
    source: vectorSource
});
map.addLayer(vectorLayer);

// Load and display markers with clustering for same locations
function loadMarkers() {
    const dateFilter = document.getElementById('dateFilter').value;
    const statusFilter = document.getElementById('statusFilter').value;
    
    let url = '{% url "admin_attendance_geo_data" %}';
    const params = new URLSearchParams();
    if (dateFilter) params.append('date', dateFilter);
    if (statusFilter) params.append('status', statusFilter);
    if (params.toString()) url += '?' + params.toString();
    
    console.log('Loading markers from:', url);
    
    fetch(url)
        .then(response => response.json())
        .then(result => {
            console.log('API Response:', result);
            
            // Clear existing markers
            vectorSource.clear();
            
            const data = result.data || [];
            
            if (!data || data.length === 0) {
                console.log('No location data found');
                alert(`No GPS attendance data found. ${result.message || 'Please try different filters.'}`);
                return;
            }
            
            console.log(`Processing ${data.length} location markers`);
            
            // Group markers by location to handle overlapping
            const locationGroups = {};
            
            data.forEach((record, index) => {
                const lat = parseFloat(record.lat);
                const lng = parseFloat(record.lng);
                
                if (isNaN(lat) || isNaN(lng)) {
                    console.warn(`Invalid coordinates for ${record.employee_id}`);
                    return;
                }
                
                // Create location key (rounded to avoid floating point issues)
                const locationKey = `${lat.toFixed(6)}_${lng.toFixed(6)}`;
                
                if (!locationGroups[locationKey]) {
                    locationGroups[locationKey] = {
                        lat: lat,
                        lng: lng,
                        records: []
                    };
                }
                
                locationGroups[locationKey].records.push(record);
            });
            
            console.log(`Found ${Object.keys(locationGroups).length} unique locations`);
            
            // Create markers for each location group
            Object.values(locationGroups).forEach((group, groupIndex) => {
                const records = group.records;
                
                if (records.length === 1) {
                    // Single marker at this location
                    createSingleMarker(records[0], group.lat, group.lng);
                } else {
                    // Multiple markers - create clustered markers with offsets
                    createClusteredMarkers(records, group.lat, group.lng);
                }
            });
            
            console.log(`Total markers created: ${vectorSource.getFeatures().length}`);
            
            // Fit map to show all markers
            if (vectorSource.getFeatures().length > 0) {
                map.getView().fit(vectorSource.getExtent(), {
                    padding: [50, 50, 50, 50],
                    maxZoom: 18
                });
            }
        })
        .catch(error => {
            console.error('Error loading geo data:', error);
            alert('Error loading location data. Please try again.');
        });
}

// Create single marker
function createSingleMarker(record, lat, lng) {
    const feature = new ol.Feature({
        geometry: new ol.geom.Point(ol.proj.fromLonLat([lng, lat]))
    });
    
    setMarkerProperties(feature, record, lat, lng);
    setMarkerStyle(feature, record, false);
    vectorSource.addFeature(feature);
    
    console.log(`Created single marker for ${record.employee_id}`);
}

// Create clustered markers with offsets
function createClusteredMarkers(records, baseLat, baseLng) {
    console.log(`Creating ${records.length} clustered markers at ${baseLat}, ${baseLng}`);
    
    records.forEach((record, index) => {
        // Calculate offset for overlapping markers (in meters)
        const offsetDistance = 15; // 15 meters apart
        const angle = (index * 360 / records.length) * Math.PI / 180; // Distribute in circle
        
        // Convert offset to lat/lng (approximate)
        const latOffset = (offsetDistance * Math.cos(angle)) / 111000; // 1 degree ≈ 111km
        const lngOffset = (offsetDistance * Math.sin(angle)) / (111000 * Math.cos(baseLat * Math.PI / 180));
        
        const offsetLat = baseLat + latOffset;
        const offsetLng = baseLng + lngOffset;
        
        const feature = new ol.Feature({
            geometry: new ol.geom.Point(ol.proj.fromLonLat([offsetLng, offsetLat]))
        });
        
        setMarkerProperties(feature, record, offsetLat, offsetLng);
        setMarkerStyle(feature, record, true, records.length);
        vectorSource.addFeature(feature);
        
        console.log(`Created clustered marker ${index + 1}/${records.length} for ${record.employee_id}`);
    });
}

// Set marker properties
function setMarkerProperties(feature, record, lat, lng) {
    feature.setProperties({
        employee_id: record.employee_id,
        name: record.name,
        designation: record.designation,
        dccb: record.dccb,
        status: record.status,
        is_late: record.is_late,
        timing_status: record.timing_status,
        marked_at: record.marked_at,
        check_in_time: record.check_in_time,
        location_address: record.location_address,
        location_accuracy: record.location_accuracy,
        distance_from_office: record.distance_from_office,
        is_location_valid: record.is_location_valid,
        coordinates: `${lat.toFixed(8)}, ${lng.toFixed(8)}`,
        date: record.date
    });
}

// Set marker style
function setMarkerStyle(feature, record, isClustered, clusterSize = 1) {
    let color = 'green';
    let strokeColor = 'white';
    let strokeWidth = 3;
    
    if (record.status === 'absent') {
        color = 'red';
    } else if (record.status === 'half_day') {
        color = 'blue';
    } else if (record.is_late) {
        color = 'orange';
    }
    
    // Add accuracy indicator
    if (record.location_accuracy) {
        if (record.location_accuracy > 50) {
            strokeColor = 'red';
            strokeWidth = 4;
        } else if (record.location_accuracy > 20) {
            strokeColor = 'orange';
            strokeWidth = 3;
        } else {
            strokeColor = 'green';
            strokeWidth = 2;
        }
    }
    
    // Adjust size for clustered markers
    const radius = isClustered ? 10 : 12;
    const textSize = isClustered ? '10px' : '11px';
    
    feature.setStyle(new ol.style.Style({
        image: new ol.style.Circle({
            radius: radius,
            fill: new ol.style.Fill({color: color}),
            stroke: new ol.style.Stroke({color: strokeColor, width: strokeWidth})
        }),
        text: new ol.style.Text({
            text: isClustered ? record.employee_id.slice(-3) : record.employee_id, // Show last 3 chars for clustered
            font: `bold ${textSize} Arial`,
            fill: new ol.style.Fill({color: 'white'}),
            stroke: new ol.style.Stroke({color: 'black', width: 2}),
            offsetY: -25
        })
    }));
}

// Apply filters function
function applyFilters() {
    loadMarkers();
}

// Load initial markers
loadMarkers();

// Enhanced click handler for clustered markers
map.on('click', function(event) {
    const features = [];
    
    // Get all features at click point (within 10 pixel radius)
    map.forEachFeatureAtPixel(event.pixel, function(feature) {
        features.push(feature);
    }, {
        hitTolerance: 10
    });
    
    if (features.length === 0) return;
    
    if (features.length === 1) {
        // Single marker - show normal popup
        showSingleMarkerPopup(features[0]);
    } else {
        // Multiple markers - show list popup
        showMultipleMarkersPopup(features, event.coordinate);
    }
});

// Show popup for single marker
function showSingleMarkerPopup(feature) {
    const props = feature.getProperties();
    
    let info = `
        <div style="min-width: 250px;">
            <h6 style="margin: 0 0 8px 0; color: #1e3a8a;"><strong>${props.name}</strong></h6>
            <div style="font-size: 13px; line-height: 1.4;">
                <strong>Employee ID:</strong> ${props.employee_id}<br>
                <strong>Date:</strong> ${props.date}<br>
                <strong>Designation:</strong> ${props.designation}<br>
                <strong>DCCB:</strong> ${props.dccb}<br>
                <strong>Status:</strong> <span style="color: ${props.status === 'present' ? 'green' : props.status === 'absent' ? 'red' : 'blue'}">${props.status.toUpperCase()}</span><br>
                <strong>Timing:</strong> ${props.timing_status || 'N/A'}<br>
                <strong>Check-in Time:</strong> ${props.check_in_time || 'N/A'}<br>
                <strong>Marked At:</strong> ${props.marked_at}<br>
    `;
    
    if (props.location_accuracy) {
        const accuracyColor = props.location_accuracy <= 20 ? 'green' : props.location_accuracy <= 50 ? 'orange' : 'red';
        info += `<strong>GPS Accuracy:</strong> <span style="color: ${accuracyColor}">${Math.round(props.location_accuracy)}m</span><br>`;
    }
    
    if (props.distance_from_office) {
        info += `<strong>Distance from Office:</strong> ${Math.round(props.distance_from_office)}m<br>`;
    }
    
    info += `
                <strong>Coordinates:</strong> ${props.coordinates}<br>
                <strong>Address:</strong> ${props.location_address || 'Not available'}
            </div>
        </div>
    `;
    
    showPopup(info, feature.getGeometry().getCoordinates());
}

// Show popup for multiple markers at same location
function showMultipleMarkersPopup(features, coordinate) {
    let info = `
        <div style="min-width: 300px; max-height: 400px; overflow-y: auto;">
            <h6 style="margin: 0 0 10px 0; color: #1e3a8a;"><strong>${features.length} Employees at this Location</strong></h6>
    `;
    
    features.forEach((feature, index) => {
        const props = feature.getProperties();
        const statusColor = props.status === 'present' ? 'green' : props.status === 'absent' ? 'red' : 'blue';
        
        info += `
            <div style="border-bottom: 1px solid #eee; padding: 8px 0; font-size: 12px;">
                <strong style="color: #1e3a8a;">${props.employee_id} - ${props.name}</strong><br>
                <span style="color: ${statusColor}; font-weight: bold;">${props.status.toUpperCase()}</span> | 
                ${props.timing_status} | 
                ${props.check_in_time || 'N/A'}<br>
                <small>${props.designation} - ${props.dccb}</small>
            </div>
        `;
    });
    
    info += '</div>';
    
    showPopup(info, coordinate);
}

// Generic popup display function
function showPopup(content, coordinate) {
    // Remove existing popups
    map.getOverlays().clear();
    
    const popup = document.createElement('div');
    popup.innerHTML = content;
    popup.style.cssText = `
        background: white; 
        padding: 12px; 
        border: 2px solid #1e3a8a; 
        border-radius: 8px; 
        box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        font-family: Arial, sans-serif;
        max-width: 350px;
    `;
    
    const overlay = new ol.Overlay({
        element: popup,
        positioning: 'bottom-center',
        stopEvent: false,
        offset: [0, -15]
    });
    
    map.addOverlay(overlay);
    overlay.setPosition(coordinate);
    
    // Remove popup after 8 seconds or on map click
    const removePopup = () => {
        map.removeOverlay(overlay);
        map.un('click', removePopup);
    };
    
    setTimeout(removePopup, 8000);
    map.on('click', removePopup);
}
</script>
{% endblock %}